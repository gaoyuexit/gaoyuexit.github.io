<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>状态管理之Bloc初体验</title>
    <url>/2020/04/29/flutter-bloc/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>Flutter和SwiftUI是声明式和响应式编程在移动端的典范, 使用它们开发复杂业务, 状态管理是绕不过去的话题. </p>
</blockquote>
<p>BLoC【Business Logic Component】设计模式是<code>paolo soares</code> 和 <code>cong hui</code> 在2018年<code>Google dartconf</code>上提出的，具体设计思想和于传统开发方式的比较, 可以参考<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1QTEhsbjd3SGdQRQ==">YouTube演示视频<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<p>BloC设计模式是Flutter解决状态管理的一种方案, 今天笔者将使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZlbGFuZ2VsL2Jsb2M=">bloc<i class="fa fa-external-link-alt"></i></span>(实现该设计模式且比较流行的库)来构建一个工程中完整且常见的页面,  作为Flutter初学者, 希望以此和大家交流, 共同进步,   你可以在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1bGl2ZXItZC9ibG9jX2V4YW1wbGU=">这里<i class="fa fa-external-link-alt"></i></span>找到该项目的完整代码~</p>
<img src='https://github.com/juliver-d/bloc_example/blob/master/source/bloc_page.gif' alt='page' width='25%'>
<img src="/2020/04/29/flutter-bloc/bloc_page.gif" class="" title="效果 [10] [15]">

<h1 id="BLoC"><a href="#BLoC" class="headerlink" title="BLoC"></a>BLoC</h1><p>为什么选用BLoC ? </p>
<blockquote>
<p>BLoC将视图层与业务逻辑分离变得容易，从而使代码<strong>简单</strong>，<strong>可测</strong> 并且<strong>可重用</strong>, 更重要的是它以一种数据驱动的规范化流程来编写, 各个层级各司其职, 清晰分明</p>
</blockquote>
<p>如果你是Web开发者, 你肯定熟悉React+Redux、如果你是iOS开发者, 你可能会使用过RxSwift+ReactorKit,  如果你熟悉单项数据流开发模式, 那么你对BLoC就非常容易上手, BLoC就是用reactive programming方式构建应用, 一个由流构成的完全异步的世界。从而达到界面与业务分离的逻辑。</p>
<p><img src="https://github.com/juliver-d/bloc_example/blob/master/source/bloc_architecture_full.png" alt="bloc_architecture_full"></p>
<img src="/2020/04/29/flutter-bloc/bloc_architecture_full.png" class="" title="架构">

<p>通过bloc<span class="exturl" data-url="aHR0cHM6Ly9ibG9jbGlicmFyeS5kZXYvIy9hcmNoaXRlY3R1cmU/aWQ9cHJlc2VudGF0aW9uLWxheWVy">官网<i class="fa fa-external-link-alt"></i></span>介绍的流程图来看, 它将应用分为了三层: 展示层, 逻辑层, 数据层. 而通过流程来看, bloc逻辑层作为三层的中枢, 处理三个层级之间的交流.</p>
<p>并且我们可以根据官方的命名规范来组织各个层级结构: </p>
<ul>
<li><p>数据层(Data Layer):  职责是从一个或多个源中检索/处理数据。</p>
<ul>
<li>使用<code>DataProvider</code>来提供原始数据(eg: CRUD等)</li>
<li>使用<code>Repository</code>来包装一个或多个<code>DataProvider</code>, 然后与bloc进行通讯</li>
</ul>
</li>
<li><p>逻辑层(Business Logic Layer):  职责是接收表示层的事件输入, 请求检索数据, 进而以数据建立表示层的新状态</p>
<ul>
<li>多个bloc之间也可以进行通讯: 每个bloc都有一个状态流, , 其他bloc可以订阅该流, 以便对自己bloc内部做出新状态的改变</li>
</ul>
</li>
<li><p>展示层(Presentation Layer): 职责是向bloc发送用户事件, 根据一个或多个bloc的状态来进行渲染改变</p>
</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在大家了解过<span class="exturl" data-url="aHR0cHM6Ly9ibG9jbGlicmFyeS5kZXYvIy9mbHV0dGVyYmxvY2NvcmVjb25jZXB0cz9pZD1ibG9jLXdpZGdldHM=">bloc widgets<i class="fa fa-external-link-alt"></i></span>的api之后, 那就跟着我一起进行页面的开发吧😸</p>
<p>这里我已经准备好了页面所需的数据来源了:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;code&quot;</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="attr">&quot;errMsg&quot;</span>: <span class="string">&quot;操作成功&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;time&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;start_time&quot;</span>: <span class="string">&quot;21:00&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;end_time&quot;</span>: <span class="string">&quot;22:00&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">&quot;address&quot;</span>: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;types&quot;</span>: [&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;普通公寓：住宅用地，公寓产权，70年，户型面积小&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;selected&quot;</span>: <span class="number">2</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;商务公寓：商业用地，商务公寓产权，40年&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;selected&quot;</span>: <span class="number">1</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;酒店式公寓：商业用地，商务公寓或公寓产权，40年，面积较小&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;selected&quot;</span>: <span class="number">2</span></span><br><span class="line">		&#125;],</span><br><span class="line">		<span class="attr">&quot;count&quot;</span>: <span class="string">&quot;3&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单梳理下页面的需求:</p>
<ul>
<li>根据json数据, 展示页面的上的内容</li>
<li>点击提交将修改后的内容提交至服务器, 提交参数为:<code>start_time</code>, <code>end_time</code>,<code> address</code>, <code>count</code>和选中的<code>type</code>对应的value值</li>
<li>并且在点击页面返回的时候, 需要校验当然页面是否有修改过的数据, 并对用户进行弹窗展示</li>
</ul>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>定义展示模型: </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormModel</span> </span>&#123;</span><br><span class="line">  <span class="comment">///<span class="markdown">时间</span></span></span><br><span class="line">  Time time;</span><br><span class="line">  <span class="comment">///<span class="markdown">地点</span></span></span><br><span class="line">  <span class="built_in">String</span> address;</span><br><span class="line">  <span class="comment">///<span class="markdown">类型</span></span></span><br><span class="line">  <span class="built_in">List</span>&lt;SelectValueItem&gt; types;</span><br><span class="line">  <span class="comment">///<span class="markdown">次数</span></span></span><br><span class="line">  <span class="built_in">String</span> count;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///<span class="markdown">help -</span></span></span><br><span class="line">  <span class="keyword">get</span> timeString =&gt; <span class="string">&#x27;<span class="subst">$&#123;time.start&#125;</span>-<span class="subst">$&#123;time.end&#125;</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">get</span> counString =&gt; <span class="string">&#x27;<span class="subst">$&#123;count&#125;</span>次&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">///<span class="markdown">转化为提交模型</span></span></span><br><span class="line">  FormSubmit toSubmit() &#123;</span><br><span class="line">    <span class="keyword">return</span> FormSubmit(</span><br><span class="line">      start: time.start,</span><br><span class="line">      end: time.end,</span><br><span class="line">      address: address,</span><br><span class="line">      type: types.firstWhere((e) =&gt; e.selected, orElse: <span class="keyword">null</span>)?.value ?? <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">      count: count,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义提交模型</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">///<span class="markdown">提交模型</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormSubmit</span> <span class="keyword">extends</span> <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">  <span class="comment">///<span class="markdown">起始时间</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> start;</span><br><span class="line">  <span class="comment">///<span class="markdown">结束时间</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> end;</span><br><span class="line">  <span class="comment">///<span class="markdown">地址</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> address;</span><br><span class="line">  <span class="comment">///<span class="markdown">类型</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> type;</span><br><span class="line">  <span class="comment">///<span class="markdown">次数</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟网络请求(FormRepository)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _delay = <span class="built_in">Duration</span>(milliseconds: <span class="number">300</span>);</span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; wait() =&gt; Future.delayed(_delay);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormRepository</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">抓取表单数据</span></span></span><br><span class="line">  Future&lt;FormModel&gt; fetchFormData() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> wait(); <span class="comment">//模拟延迟</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> jsonString = <span class="keyword">await</span> rootBundle.loadString(<span class="string">&quot;assets/json/form_data.json&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> jsonResult = json.decode(jsonString);</span><br><span class="line">    FormModel model = FormModel.fromJson(jsonResult[<span class="string">&#x27;data&#x27;</span>]);</span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// <span class="markdown">表单保存</span></span></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; saveForm(FormSubmit model) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> wait();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p>展示数据的逻辑, 我们定义一个form_bloc处理, 为了编写bloc模板, <span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzEyMTI5LWJsb2MtY29kZS1nZW5lcmF0b3I=">Bloc Code Generator<i class="fa fa-external-link-alt"></i></span>插件可以方便的生成构建Bloc的模版代码, 有兴趣的同学可以尝试使用</p>
<p>定义Event:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FormEvent</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//请求数据事件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormDataRequestEvent</span> <span class="keyword">extends</span> <span class="title">FormEvent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>定义State:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FormDataState</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//初始状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInitState</span> <span class="keyword">extends</span> <span class="title">FormDataState</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//加载成功状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormLoadedState</span> <span class="keyword">extends</span> <span class="title">FormDataState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> FormModel data;</span><br><span class="line">  FormLoadedState(&#123;<span class="keyword">this</span>.data&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据加载失败状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormFailureState</span> <span class="keyword">extends</span> <span class="title">FormDataState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> error;</span><br><span class="line">  FormFailureState(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.error&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据请求中状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInProgressState</span> <span class="keyword">extends</span> <span class="title">FormDataState</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>定义bloc: </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormBloc</span> <span class="keyword">extends</span> <span class="title">Bloc</span>&lt;<span class="title">FormEvent</span>, <span class="title">FormDataState</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  FormDataState <span class="keyword">get</span> initialState =&gt; FormInitState();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> FormRepository repo;</span><br><span class="line">  FormBloc(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.repo&#125;) : <span class="keyword">assert</span>(repo != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;FormDataState&gt; mapEventToState(</span><br><span class="line">      FormEvent event,</span><br><span class="line">      ) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="comment">//请求</span></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">is</span> FormDataRequestEvent) &#123;</span><br><span class="line">      <span class="keyword">yield</span> FormInProgressState(); <span class="comment">//请求中状态..</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> model = <span class="keyword">await</span> repo.fetchFormData();</span><br><span class="line">        <span class="keyword">yield</span> FormLoadedState(data: model);<span class="comment">//请求成功状态(data)</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">yield</span> FormFailureState(error: error.toString());<span class="comment">//请求失败状态(error)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>展示数据: (在页面build的时候, 就可以直接发送请求事件)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">///<span class="markdown">发送事件</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> repo = FormRepository();</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MultiBlocProvider(</span><br><span class="line">      providers: [</span><br><span class="line">        BlocProvider&lt;FormBloc&gt;(</span><br><span class="line">          create: (ctx) =&gt; FormBloc(repo: repo)..add(FormDataRequestEvent()),<span class="comment">//发送请求事件</span></span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">      child: FormContent(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///<span class="markdown">页面内容展示 (这里使用BlocConsumer, 防止listener,builder嵌套)</span></span></span><br><span class="line">body: Container(</span><br><span class="line">  color: Color(<span class="number">0xFFF6FAFF</span>),</span><br><span class="line">  child: BlocConsumer&lt;FormBloc, FormDataState&gt;(</span><br><span class="line">    listener: (context, state) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state <span class="keyword">is</span> FormFailureState) &#123;<span class="comment">//请求失败-&gt;toast提示</span></span><br><span class="line">        ToastUtil.<span class="keyword">show</span>(state.error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    builder: (context, state) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state <span class="keyword">is</span> FormInProgressState) &#123;<span class="comment">//请求中-&gt;展示loading</span></span><br><span class="line">        <span class="keyword">return</span> LoadingIndicator(); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (state <span class="keyword">is</span> FormLoadedState) &#123;<span class="comment">//请求成功-&gt;根据data构建UI</span></span><br><span class="line">        <span class="keyword">var</span> model = state.data;</span><br><span class="line">        <span class="keyword">return</span> SingleChildScrollView( </span><br><span class="line">          child: Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              _sectionHeader(),</span><br><span class="line">              ContentItem(title: <span class="string">&#x27;选择区间&#x27;</span>, content: model.timeString, hasArrow: <span class="keyword">true</span>),</span><br><span class="line">              _divider(),</span><br><span class="line">              ContentItem(title: <span class="string">&#x27;选择地址&#x27;</span>, content: model.address, hasArrow: <span class="keyword">false</span>,),</span><br><span class="line">              _sectionHeader(),</span><br><span class="line">              TypeItem(items: model.types ?? [], onIndexTap: (index) =&gt; _setType(index),),</span><br><span class="line">              _divider(),</span><br><span class="line">              ContentItem(title: <span class="string">&#x27;选择次数&#x27;</span>, content: model.counString, hasArrow: <span class="keyword">false</span>,),</span><br><span class="line">              _buildSaveButton(),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Container();</span><br><span class="line">    &#125;,</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<h2 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h2><p>我们在👆上面的展示的图中可以看到,  选择区间, 更改选择类型, 这些都是需要更改数据源来进行UI更改的,  根据<strong>单项数据流模式</strong>, 数据都应由bloc来进行管理, UI层面只进行响应式的更新</p>
<p>所以, 我们最好不要在UI层面来操作数据源, 而是发送<code>选择区间</code>,<code>选择类型</code>的事件, 来让bloc进行数据源状态的改变</p>
<p>定义两个Event:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新时间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormUpdateTimeEvent</span> <span class="keyword">extends</span> <span class="title">FormEvent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> start;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> end;</span><br><span class="line">  FormUpdateTimeEvent(&#123;<span class="keyword">this</span>.start, <span class="keyword">this</span>.end&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormUpdateTypeEvent</span> <span class="keyword">extends</span> <span class="title">FormEvent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> selectIndex;</span><br><span class="line">  FormUpdateTypeEvent(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.selectIndex&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更改相应的State (更改后, bloc获取到的state中的data为最新的数据源)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Stream&lt;FormDataState&gt; mapEventToState(</span><br><span class="line">    FormEvent event,</span><br><span class="line">    ) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="comment">//更新类型</span></span><br><span class="line">  <span class="keyword">if</span> (event <span class="keyword">is</span> FormUpdateTypeEvent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state <span class="keyword">is</span> FormLoadedState) &#123;</span><br><span class="line">      <span class="keyword">var</span> model = (state <span class="keyword">as</span> FormLoadedState).data;</span><br><span class="line">      model.types.forEach((e) =&gt; e.selected = <span class="keyword">false</span> ); <span class="comment">//列表中取消所有选中</span></span><br><span class="line">      model.types[event.selectIndex].selected = <span class="keyword">true</span>;  <span class="comment">//selectIndex下标数据置为选中</span></span><br><span class="line">      <span class="keyword">yield</span> (state <span class="keyword">as</span> FormLoadedState).copyWith(data: model); <span class="comment">//发送新数据源的FormLoadedState状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//更新时间</span></span><br><span class="line">  <span class="keyword">if</span> (event <span class="keyword">is</span> FormUpdateTimeEvent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state <span class="keyword">is</span> FormLoadedState) &#123;</span><br><span class="line">      <span class="keyword">var</span> model = (state <span class="keyword">as</span> FormLoadedState).data;</span><br><span class="line">      model.time.start = event.start;</span><br><span class="line">      model.time.end = event.end;</span><br><span class="line">      <span class="keyword">yield</span> (state <span class="keyword">as</span> FormLoadedState).copyWith(data: model);<span class="comment">//发送新数据源的FormLoadedState状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那么我们只需要在页面UI层面, 发送定义的这两个事件即可</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">///<span class="markdown">选择区间</span></span></span><br><span class="line"><span class="keyword">void</span> _setTime(<span class="built_in">String</span> start, <span class="built_in">String</span> end) &#123;</span><br><span class="line">  BlocProvider.of&lt;FormBloc&gt;(context).add(FormUpdateTimeEvent(start: start, end: end));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///<span class="markdown">选择类型</span></span></span><br><span class="line"><span class="keyword">void</span> _setType(<span class="built_in">int</span> index) &#123;</span><br><span class="line">  BlocProvider.of&lt;FormBloc&gt;(context).add(FormUpdateTypeEvent(selectIndex: index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结以上完成的显示和更改, 我们用的一个bloc和对应的多个状态, 其实我们也可以将所有逻辑包装成一个页面的state, 将所有的数据包含在一个state中, 所有的Event对应的State都为同一个, 那么事件的处理一般都为<code>yeild state.copyWith(..)</code>   </p>
<p>伪代码如这样:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> DataState &#123;</span><br><span class="line">  init,</span><br><span class="line">  loading,</span><br><span class="line">  loaded,</span><br><span class="line">  fail,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormPageDataState</span> <span class="keyword">extends</span> <span class="title">FormDataState</span> </span>&#123;</span><br><span class="line">  FormModel data, <span class="comment">//数据</span></span><br><span class="line">  FormSubmit submitData,<span class="comment">//提交数据</span></span><br><span class="line">  DataState dataState,</span><br><span class="line">  ... <span class="comment">//等其他数据</span></span><br><span class="line">  </span><br><span class="line">  FormPageDataState copyWith(&#123;</span><br><span class="line">  FormModel data,</span><br><span class="line">  FormSubmit submitData,</span><br><span class="line">  DataState dataState,</span><br><span class="line">	&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> FormLoadedState(</span><br><span class="line">    data: data ?? <span class="keyword">this</span>.data,</span><br><span class="line">    submitData: submitData ?? <span class="keyword">this</span>.submitData,</span><br><span class="line">    dataState: dataState ?? <span class="keyword">this</span>.dataState,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>提交这部分逻辑 , 我决定使用另一个bloc来处理逻辑<code>submit_bloc</code>, 我们会思考提交的状态有什么: </p>
<p>默认状态, 提交请求中, 请求成功, 请求失败</p>
<p>咦 ??  那所有的请求几乎都是这样, 那我们不如定义一个普通情况下都通用的状态State: </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkState</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkInitState</span> <span class="keyword">extends</span> <span class="title">NetworkState</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkSuccessState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">NetworkState</span> </span>&#123; <span class="comment">//使用泛型定义数据</span></span><br><span class="line">  <span class="keyword">final</span> T data;</span><br><span class="line">  NetworkSuccessState(&#123;<span class="keyword">this</span>.data&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkFailureState</span> <span class="keyword">extends</span> <span class="title">NetworkState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> error;</span><br><span class="line">  NetworkFailureState(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.error&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkInProgressState</span> <span class="keyword">extends</span> <span class="title">NetworkState</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下提交的Bloc, 是不是简单多了: </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown"><span class="bullet">-</span> Event</span></span></span><br><span class="line"><span class="comment">//提交</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubmitEvent</span> </span>&#123;</span><br><span class="line">  SubmitEvent(&#123;<span class="keyword">this</span>.submit&#125;);</span><br><span class="line">  FormSubmit submit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="markdown"><span class="bullet">-</span> State -&gt; NetworkState</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="markdown"><span class="bullet">-</span> Bloc</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubmitBloc</span> <span class="keyword">extends</span> <span class="title">Bloc</span>&lt;<span class="title">SubmitEvent</span>, <span class="title">NetworkState</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  NetworkState <span class="keyword">get</span> initialState =&gt; NetworkInitState();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> FormRepository repo;</span><br><span class="line">  SubmitBloc(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.repo&#125;) : <span class="keyword">assert</span>(repo != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;NetworkState&gt; mapEventToState(</span><br><span class="line">      SubmitEvent event,</span><br><span class="line">      ) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="keyword">yield</span> NetworkInProgressState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">bool</span> result = <span class="keyword">await</span> repo.saveForm(event.submit);</span><br><span class="line">      <span class="keyword">yield</span> NetworkSuccessState&lt;<span class="built_in">bool</span>&gt;(data: result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">yield</span> NetworkFailureState(error: error.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>点击返回按钮的时候, 我们需要判断需要提交的数据是否变化了, 我们在该页面请求成功的State中, 添加一个初始化提交模型</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormLoadedState</span> <span class="keyword">extends</span> <span class="title">FormDataState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> FormModel data;</span><br><span class="line">  <span class="keyword">final</span> FormSubmit initSubmit; <span class="comment">//初始化提交模型</span></span><br><span class="line">  FormLoadedState(&#123;<span class="keyword">this</span>.data, <span class="keyword">this</span>.initSubmit&#125;);</span><br><span class="line"></span><br><span class="line">  FormLoadedState copyWith(&#123;</span><br><span class="line">    FormModel data,</span><br><span class="line">    FormSubmit initSubmitModel,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> FormLoadedState(</span><br><span class="line">      data: data ?? <span class="keyword">this</span>.data,</span><br><span class="line">      initSubmit: initSubmitModel ?? <span class="keyword">this</span>.initSubmit,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求Event对应的State为: </span></span><br><span class="line"><span class="keyword">if</span> (event <span class="keyword">is</span> FormDataRequestEvent) &#123;</span><br><span class="line">  <span class="keyword">yield</span> FormInProgressState();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> model = <span class="keyword">await</span> repo.fetchFormData();</span><br><span class="line">    <span class="keyword">yield</span> FormLoadedState(data: model, initSubmit: model.toSubmit()); <span class="comment">//state中增加一个initSubmit属性</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">yield</span> FormFailureState(error: error.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看下UI层的事件处理: </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> WillPopScope(</span><br><span class="line">      onWillPop: () =&gt; _exitPage(context),</span><br><span class="line">      child: ...</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出</span></span><br><span class="line">Future&lt;<span class="built_in">bool</span>&gt; _exitPage(BuildContext context) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> state = BlocProvider.of&lt;FormBloc&gt;(context).state;</span><br><span class="line">  <span class="keyword">if</span> (state <span class="keyword">is</span> FormLoadedState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state.data.toSubmit() != state.initSubmit) &#123;</span><br><span class="line">      <span class="comment">//数据有变化, 弹窗</span></span><br><span class="line">      JLDialog.cancelConfirmTextDialog(context, content: <span class="string">&#x27;内容已经变更，是否保存？&#x27;</span>).then((confirm) &#123;</span><br><span class="line">        confirm ? _confirmSave() : Navigator.of(context).pop();</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1bGl2ZXItZC9ibG9jX2V4YW1wbGU=">完整示例代码在这里<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZlbGFuZ2VsL2Jsb2M=">https://github.com/felangel/bloc<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzRzZWVyL29wZW5mbHV0dGVyZWNvbW1lcmNlYXBw">https://github.com/4seer/openflutterecommerceapp<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Bloc</tag>
      </tags>
  </entry>
  <entry>
    <title>博客折腾小记</title>
    <url>/2018/03/27/hexo-next-theme/</url>
    <content><![CDATA[<blockquote>
<p>最近又折腾了一下博客, 更换了主题</p>
</blockquote>
<span id="more"></span>

<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><h3 id="配置主题文件"><a href="#配置主题文件" class="headerlink" title="配置主题文件"></a>配置主题文件</h3><p>根据 Hexo 官方的推荐，不要直接修改主题的配置文件</p>
<blockquote>
<p>The file should be placed in your site folder, both yml and json are supported. theme inside  _config.yml must be configured for Hexo to read _config.[theme].yml</p>
</blockquote>
<ol>
<li><p>配置主题为 Next 主题</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">&quot;next&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在 site 根目录新建 <code>_config.next.yml</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch _config.next.yml</span></span><br></pre></td></tr></table></figure></li>
<li><p>打开 <code>theme/next/_config.yml</code>把需要修改的选项 copy 到 <code>_config.next.yml</code>中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.next.yml</span></span><br><span class="line"><span class="comment"># 设置网站图标</span></span><br><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/favicon.ico</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/favicon.ico</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/apple-touch-icon.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/apple-touch-icon.png</span></span><br></pre></td></tr></table></figure></li>
<li><p>hexo启动时，会自动合并 <code>_config.next.yml</code> 与<code>theme/next/_config.yml</code> 的设置内容，从而达到配置主题的作用。</p>
</li>
</ol>
<blockquote>
<p>这样我们可以不直接修改theme/next中的内容, 每次拉取theme/next仓库中的更新时, 不会因修改了<code>_config.yml</code>而发生冲突。（每个主题都是一个独立的 <code>git</code>项目）</p>
</blockquote>
<h3 id="修改主题样式"><a href="#修改主题样式" class="headerlink" title="修改主题样式"></a>修改主题样式</h3><blockquote>
<p> Hexo的NexT主题采用njk来作为HTML预处理器，使用styl来扩展css，所以可以简单的理解成 (html \ subset njk) ，(css \ subset styl)。它们扩充了相应的功能和语法支持来更加高效的架构网页，当然，我们也完全可以使用html和css的语法来美化我们的网页。</p>
</blockquote>
<p>因为每个主题都是一个独立的 <code>git</code>项目, 每个主题的安装大都为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>

<p>一般我们都会更改自己的主题,不推荐直接在themes/next仓库内直接进行修改, 这样在拉取最新的主题更新时, 我们的修改会被覆盖/冲突。</p>
<h4 id="1-指定custom-file-path来修改"><a href="#1-指定custom-file-path来修改" class="headerlink" title="1. 指定custom_file_path来修改"></a>1. 指定custom_file_path来修改</h4><p>更改主题的方式hexo可以使用指定custom_file_path的样式文件styles.styl来进行样式覆盖, 比如head.njk文件来进行预处理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">head:</span> <span class="string">source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="attr">postBodyEnd:</span> <span class="string">source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="attr">bodyEnd:</span> <span class="string">source/_data/body-end.njk</span></span><br><span class="line">  <span class="attr">variable:</span> <span class="string">source/_data/variables.styl</span></span><br><span class="line">  <span class="attr">mixin:</span> <span class="string">source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>

<p>比如指定的source/_data/styles.styl来进行覆盖默认样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* header-页面背景 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">$body-bg-url</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>: repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sidebar-标题 */</span></span><br><span class="line"><span class="selector-class">.site-title</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用submodule管理主题"><a href="#2-使用submodule管理主题" class="headerlink" title="2. 使用submodule管理主题"></a>2. 使用submodule管理主题</h4><ol>
<li>在GitHub上，把原作者的主题fork到我们自己的仓库中</li>
<li>运行以下命令，把fork的NexT主题添加为我们博客的子模块</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git submodule add https://github.com/&lt;username&gt;/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>

<p>我们可以把自己修改的主题提交到我们自己fork的仓库中进行存储</p>
<p>submodule命令会在目录下多一个<code>.gitmodules</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat .gitmodules</span></span><br><span class="line">[submodule &quot;themes/next&quot;]</span><br><span class="line">    path = themes/next</span><br><span class="line">    url = git@github.com:gaoyuexit/hexo-theme-next</span><br></pre></td></tr></table></figure>

<p>如何进行版本控制 ? </p>
<p>1.推送至 GitHub</p>
<p>当我们对主题（子模块）的内容进行修改时，Hexo 站点（主模块）只知道我们进行了修改，但是并不会管理我们具体进行了什么修改。</p>
<blockquote>
<p>因此，子模块和主模块需要分开 push，一般先推送子模块，后推送主模块。</p>
</blockquote>
<p>2.从原作者处更新主题</p>
<p>如果使用的主题仍在被维护，那么我们就能从远程获取更新:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git submodule update --remote</span></span><br></pre></td></tr></table></figure>

<p>3.在另一台电脑上工作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> --recursive &lt;your repo address&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者 (👆 和 👇 的命令功能是一样的)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;your repo address&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule update --init</span></span><br></pre></td></tr></table></figure>

<p>4.删除submodule</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git submodule deinit &lt;submodule-name&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="看板娘"><a href="#看板娘" class="headerlink" title="看板娘"></a>看板娘</h2><h3 id="简易版hexo-helper-live2d"><a href="#简易版hexo-helper-live2d" class="headerlink" title="简易版hexo-helper-live2d"></a>简易版<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VZSE4vaGV4by1oZWxwZXItbGl2ZTJk">hexo-helper-live2d<i class="fa fa-external-link-alt"></i></span></h3><h3 id="功能版live2d-widget"><a href="#功能版live2d-widget" class="headerlink" title="功能版live2d-widget"></a>功能版<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0ZXZlbmpvZXpoYW5nL2xpdmUyZC13aWRnZXQ=">live2d-widget<i class="fa fa-external-link-alt"></i></span></h3><p>以<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0ZXZlbmpvZXpoYW5nL2xpdmUyZC13aWRnZXQ=">live2d-widget<i class="fa fa-external-link-alt"></i></span>为例, 先fork项目到自己的github仓库, 方便后续自己定制</p>
<p>在/themes/next/layout/_layout.swig的<code>head</code>标签内添加如下代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/gaoyuexit/live2d-widget@latest/autoload.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Pjax"><a href="#Pjax" class="headerlink" title="Pjax"></a><em>Pjax</em></h2><p><strong>单页应用</strong>（英语：single-page application，缩写<strong>SPA</strong>）是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。<strong>与单页应用的交互通常涉及到与网页服务器后端的动态通信</strong>。说白了也就是通过 <code>pushState() + XHR</code> 技术实现的页面切换。</p>
<p>而 Hexo 站点本身是个静态页面，无法发出动态请求，所以这里便引出了本文的主角 Pjax 框架了。其思路是通过拦截 <code>a</code> 链接，发送 XHR 请求，获取下级页面内容，接着替换指定区域完成整个过程。由于不是动态网站，Pjax 在请求过程中获取的是整个站点的 Html 内容，所以请求本身是无法达到加速的，但是可以减少页面中 JS 文件的重复请求，此外还可以利用一些预加载技术（预读缓存）和磁盘缓存进一步提升访问速度，实际体验效果是极佳的。</p>
<p>我们的页面存在着大量的事件监听处理。不巧的是在替换内容时，会发生部分事件监听丢失了，异常、错误、功能失效等等。</p>
<p>Javascript 部分自然是需要重新绑定注册的，但也不能无脑全部重新绑定, 否则会导致<strong>重复事件监听</strong>，它或许不会立即爆发危害，但是随着浏览页面的增加，事件绑定可能会越来越累加，影响效率，潜在造成错误等等。所以这里就需要利用 <code>send</code> 和 <code>complete</code> 这对事件了，合理利用，正确解决问题。</p>
<p>比如, 开启我的博客开启<em>Pjax</em>属性, 博客会局部刷新了, 加载速度也变快了, 我的音乐播放器可以全局播放了,  但是每个页面的评论消息错乱了或消失了, 只有<code>command + r</code>刷新整个页面, 才能加载出来。</p>
<p>解决, 在<code>/themes/next/layout/_scripts/pjax.swig</code>目录下, 根据这些函数重新调用加载<strong>拉取评论</strong>的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;pjax:send&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;pjax:complete&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;pjax:error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>因为以后博客的插件越来越多(搜索、评论、懒加载、图片弹出层、代码复制、背景幻灯片、音乐播放器、按钮涟漪动画、页面平滑滚动、公式、不蒜子计数、网址预加载),  这其中，有些无需处理，有些简单的封装成函数重新调用一下即可，而有些则就需要特意分析处理了。</p>
<p>因此暂时将该功能先关闭掉了</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9xaWFubGluZy5wdy9oZXhvLW9wdGltaXphdGlvbi8=">Hexo优化汇总<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2VtaW5pbGlnaHQuY24vMjAyMC8wOC8xNi9TVCUyMC0lMjAlRTglQkQlQUYlRTQlQkIlQjYlRTUlQjclQTUlRTUlODUlQjcvc3QtaGV4by1uZXh0LWN1c3RvbS8=">深度美化和定制Hexo和NexT方法<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDk3MTAxOTE=">为 Hexo 博客更换主题<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9pbmtzcy5jbi9ibG9nLzgwYjVmMjM1Lw==">Hexo博客部署Pjax局部刷新<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9pY2FydXMuaGNsb25lbHkuY29tL3Bvc3RzLzQwOWQzMDkwLw==">Valine添加博主标签及评论微信、QQ通知<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmhjbG9uZWx5LmNvbS8=">hclonely blog<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>编译速度优化初探</title>
    <url>/2020/04/02/optimize-compilation-speed/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>稍微调研下优化编译时长, 除硬件设备和Xcode一些编译配置项外, 大体有以下👇几种方案:</p>
<span id="more"></span>


<h2 id="编译速度优化"><a href="#编译速度优化" class="headerlink" title="编译速度优化"></a>编译速度优化</h2><h3 id="缓存编译产物"><a href="#缓存编译产物" class="headerlink" title="缓存编译产物"></a>缓存编译产物</h3><h4 id="CCache"><a href="#CCache" class="headerlink" title="CCache"></a>CCache</h4><blockquote>
<p>把编译的中间产物缓存起来的工具, <span class="exturl" data-url="aHR0cDovL2xpbmsuemhpaHUuY29tLz90YXJnZXQ9aHR0cHM6Ly9wc3BkZmtpdC5jb20vYmxvZy8yMDE1L2NjYWNoZS1mb3ItZnVuLWFuZC1wcm9maXQv">Using ccache for Fun and Profit | Inside PSPDFKit<i class="fa fa-external-link-alt"></i></span>, 使用简单</p>
</blockquote>
<p>缺点: 不支持 Clang Modules、PCH, Swift</p>
<h4 id="Buck-amp-Bazel"><a href="#Buck-amp-Bazel" class="headerlink" title="Buck &amp; Bazel"></a>Buck &amp; Bazel</h4><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC9idWNrYnVpbGQuY29t">Buck<i class="fa fa-external-link-alt"></i></span> 是Facebook 开源, <span class="exturl" data-url="aHR0cDovL2xpbmsuemhpaHUuY29tLz90YXJnZXQ9aHR0cHM6Ly9iYXplbC5idWlsZC8=">Bazel<i class="fa fa-external-link-alt"></i></span>是Google 开源, 它们能智能的增量编译, 进而提高构建速度, 之前用在安卓, 已经适配了iOS.</p>
</blockquote>
<p>优点: </p>
<ol>
<li>缓存了编译结果，通过持续监视项目目录的文件变化，每次编译时只编译有改动的文件。 </li>
<li>通过一台缓存文件服务器来保存大家的编译结果，只要团队里其中一人编译过的文件，其他人就不用再编译了，直接下载就行。</li>
</ol>
<p>缺点: </p>
<ol>
<li>因为由<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC9idWNrYnVpbGQuY29t">Buck<i class="fa fa-external-link-alt"></i></span>接管了项目编译的过程, 所以项目进行大幅度调整</li>
</ol>
<blockquote>
<p>这个方案不错, 可以进行参考, 听说我们的安卓团队小伙伴就是通过脚本来进行监听项目文件变化, 来进行增量编译, 后续可以去取经~</p>
</blockquote>
<h3 id="分布式编译"><a href="#分布式编译" class="headerlink" title="分布式编译"></a>分布式编译</h3><blockquote>
<p>把编译任务分派到内网的多台服务器上，服务器编译完成后把编译产物传回来。比较出名的是<code>distcc</code>。</p>
</blockquote>
<p>这种方案没有深入调研。</p>
<h3 id="组件二进制化"><a href="#组件二进制化" class="headerlink" title="组件二进制化"></a>组件二进制化</h3><h4 id="平滑组件库改造"><a href="#平滑组件库改造" class="headerlink" title="平滑组件库改造"></a>平滑组件库改造</h4><blockquote>
<p>通过引入变量的方式, 在podspec文件中进行判断是使用源码还是二进制的source</p>
</blockquote>
<p>缺点: 需要一个一个库的改造, 且podspec的库版本是使用json格式来进行缓存的, 引入变量不知是否会有问题</p>
<h4 id="Carthage"><a href="#Carthage" class="headerlink" title="Carthage"></a>Carthage</h4><blockquote>
<p>Carthage可以将一部分不常变的库打包成framework，可以比较方便地调试源码, 但是对于项目的改动较大</p>
</blockquote>
<h4 id="cocoapods-packager"><a href="#cocoapods-packager" class="headerlink" title="cocoapods-packager"></a>cocoapods-packager</h4><blockquote>
<p>仅需要通过podspec文件, 在lint通过后就可以将pod打包成Static Library。但是有很长时间没有更新了。</p>
</blockquote>
<h4 id="cocoapods-binary"><a href="#cocoapods-binary" class="headerlink" title="cocoapods-binary"></a>cocoapods-binary</h4><blockquote>
<p> 原理是通过 CocoaPods 提供的 pre_install hook 在 pod install 的 prepare 阶段拦截到当前的 pod install context，进而 fork 出一份独立的 installer 以完成将预编译源码 clone 至 Pod/_Prebuild 目录下。</p>
</blockquote>
<p>使用很简单, 试用了一下: </p>
<p>会拖慢pod install速度, 源码切换调试后, 缓存会被清理, 需要重新编译。这个对于项目第一次编译来说没有任何作用,  而打包等场景更多的是优化第一次的编译速度</p>
<h4 id="cocoapods-bin-amp-cocoapods-imy-bin"><a href="#cocoapods-bin-amp-cocoapods-imy-bin" class="headerlink" title="cocoapods-bin &amp; cocoapods-imy-bin"></a>cocoapods-bin &amp; cocoapods-imy-bin</h4><blockquote>
<p> <code>cocoapods-imy-bin</code>算是<code>cocoapods-bin</code>的强化版, 增添了很多功能, 总体适用下来侵入性低, 功能比较全。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>如果选用二进制化方案, 可以预见性的一些问题有一下几点: </p>
</blockquote>
<ol>
<li><p>单私有源, 没有服务端缓存的不可取, 对于第一次编译没有效果</p>
</li>
<li><p>我们有多种方式生成静态库,  在使用服务端缓存时, 一定不要使用Git来管理二进制文件, 会拖慢Git拉取的速度, 毕竟Git的缓存机制来说是不能管理大文件的, 推荐静态服务器。</p>
</li>
</ol>
<h3 id="完善头文件的搜索机制"><a href="#完善头文件的搜索机制" class="headerlink" title="完善头文件的搜索机制"></a>完善头文件的搜索机制</h3><blockquote>
<p>1: cocoapods-hmap-prebuilt 是美团一款 cocoapods 插件，以 <span class="exturl" data-url="aHR0cHM6Ly9jbGFuZy5sbHZtLm9yZy9kb3h5Z2VuL2NsYXNzY2xhbmdfMV8xSGVhZGVyTWFwLmh0bWw=">Header Map 技术<i class="fa fa-external-link-alt"></i></span> 为基础，提升代码的编译速度，完善头文件的搜索机制。</p>
<p>2: Clang Module</p>
</blockquote>
<p>未尝试, 美团文章中提供的cocoapods-hmap-prebuilt的source无法访问, 下载不了gem</p>
<p>不过原理已经告诉了我们, 也是一种努力的方向</p>
<h2 id="Ruby工具链"><a href="#Ruby工具链" class="headerlink" title="Ruby工具链"></a>Ruby工具链</h2><p>目前流行的 Ruby 环境管理工具有 RVM 和 rbenv。我们使用那一种都可以, RVM较重, rbenv轻量级。</p>
<p>但是这两个工具是不兼容的, 我们只能选择其一, 即在搜索ruby的sdk时, 只有一个是可见的。</p>
<p>两个的安装和使用这里不在赘述, 下面为官方文档: </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ydWJ5LWNoaW5hLm9yZy93aWtpL3J2bS1ndWlkZQ==">RVM实用指南<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ydWJ5LWNoaW5hLm9yZy93aWtpL3J2bS1ndWlkZQ==">rbenv实用指南<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="编写cocoapods插件"><a href="#编写cocoapods插件" class="headerlink" title="编写cocoapods插件"></a>编写cocoapods插件</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NvY29hUG9kcy9jb2NvYXBvZHMtcGx1Z2lucw==">cocoapods-plugins文档<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">// 安装</span><br><span class="line">gem install cocoapods<span class="literal">-plugins</span></span><br><span class="line">// 创建</span><br><span class="line">pod plugins create NAME [<span class="type">TEMPLATE_URL</span>]</span><br><span class="line">// eg:</span><br><span class="line">pod plugins create author</span><br></pre></td></tr></table></figure>

<p>如何使用: </p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">// 查看安装过的插件</span><br><span class="line">pod plugins installed</span><br><span class="line">// 查看已知的插件</span><br><span class="line">pod plugins list</span><br><span class="line">// 查找插件</span><br><span class="line">pod plugins search QUERY</span><br><span class="line">// 发布自己的插件</span><br><span class="line">pod plugins publish</span><br></pre></td></tr></table></figure>

<p>目录结构:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Gemfile</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── Rakefile</span><br><span class="line">├── cocoapods<span class="literal">-author</span>.gemspec</span><br><span class="line">├── lib</span><br><span class="line">│   ├── cocoapods<span class="literal">-author</span></span><br><span class="line">│   │   ├── command</span><br><span class="line">│   │   │   └── author.rb</span><br><span class="line">│   │   ├── command.rb</span><br><span class="line">│   │   └── gem_version.rb</span><br><span class="line">│   ├── cocoapods<span class="literal">-author</span>.rb</span><br><span class="line">│   └── cocoapods_plugin.rb</span><br><span class="line">└── spec</span><br><span class="line">    ├── command</span><br><span class="line">    │   └── author_spec.rb</span><br><span class="line">    └── spec_helper.rb</span><br></pre></td></tr></table></figure>

<p>解析author.rb的内容</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Pod</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Command</span></span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Author</span> &lt; Command</span></span><br><span class="line">      <span class="comment"># pod plugins list 时，展示的概要信息</span></span><br><span class="line">      <span class="keyword">self</span>.summary = <span class="string">&#x27;Short description of cocoapods-author.&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># --help / 命令错误时展示的描述信息</span></span><br><span class="line">      <span class="keyword">self</span>.description = &lt;&lt;-DESC</span><br><span class="line">        Longer description of cocoapods-author.</span><br><span class="line">      DESC</span><br><span class="line"></span><br><span class="line">      <span class="comment"># --help / 命令错误时展示的参数信息</span></span><br><span class="line">      <span class="keyword">self</span>.arguments = <span class="string">&#x27;NAME&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(argv)</span></span></span><br><span class="line">        <span class="variable">@name</span> = argv.shift_argument</span><br><span class="line">        <span class="keyword">super</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 校验方法（查看文件是否存在等）</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">validate!</span></span></span><br><span class="line">        <span class="keyword">super</span></span><br><span class="line">        help! <span class="string">&#x27;A Pod name is required.&#x27;</span> <span class="keyword">unless</span> @name</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 运行命令</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">run</span></span></span><br><span class="line">        UI.puts <span class="string">&quot;Add your implementation for the cocoapods-author plugin in <span class="subst">#&#123;<span class="keyword">__FILE__</span>&#125;</span>&quot;</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="RubyMine调试cocoapods插件"><a href="#RubyMine调试cocoapods插件" class="headerlink" title="RubyMine调试cocoapods插件"></a>RubyMine调试cocoapods插件</h2><p><strong>RubyMine</strong>是一个Ruby的IDE开发工具, 当然我们也可以使用<strong>VSCode</strong>来进行调试和开发</p>
<p>RubyMine是一个可以免费使用30天的收费软件,  这里我使用的是破解版本</p>
<h3 id="准备源码"><a href="#准备源码" class="headerlink" title="准备源码"></a>准备源码</h3><p>我们可以调试任意的cocoapods插件, 我们以<code>cocoapods-imy-bin</code>为例, ``cocoapods-imy-bin<code>是一款可以使源码库转换为二进制的插件, 是</code>cocoapods-bin`的强化版本</p>
<p>创建目录<code>imy-bin</code>:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">imy<span class="literal">-bin</span></span><br><span class="line">├── Gemfile <span class="comment">#bundle的依赖文件</span></span><br><span class="line">├── cocoapods<span class="literal">-imy</span><span class="literal">-bin</span> <span class="comment">#插件的源码</span></span><br><span class="line">├── PodDemo <span class="comment">#这个就是一个随便用xcode建立的iOS的使用podfile的demo工程</span></span><br></pre></td></tr></table></figure>

<p>其中<code>Gemfile</code>中的内容为: </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#国内的源比较快</span></span><br><span class="line"><span class="comment">#source &#x27;https://rubygems.org&#x27;</span></span><br><span class="line">source <span class="string">&#x27;https://gems.ruby-china.com&#x27;</span></span><br><span class="line"></span><br><span class="line">gem <span class="string">&#x27;cocoapods-imy-bin&#x27;</span> , <span class="symbol">:path</span> =&gt; <span class="string">&quot;./cocoapods-imy-bin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面的代码不用写,因为RubyMine在调试时,会自动安装这些gem, 如果是vscode调试的话, 需要安装gem</span></span><br><span class="line">group <span class="symbol">:debug</span> <span class="keyword">do</span></span><br><span class="line">    gem <span class="string">&#x27;ruby-debug-ide&#x27;</span></span><br><span class="line">    gem <span class="string">&#x27;debase&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>在当前目录下建立<code>./bundle/config</code>文件, <code>config</code>内容如下: </p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">BUNDLE_PATH: <span class="string">&quot;vendor/bundle&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行 bundle install, 将会把Gemfile文件中所申明的依赖都安装到vendor/bundle目录下</p>
<p>因为我们是调试某个gem库, 为了不影响我们已经安装的, 安装依赖的时候, 最好是安装到当前文件夹下的执行目录中去, bundle会检查, 如果配置了<code>config</code>文件的话, 是可以在配置文件中声明安装的目录的。</p>
<p>而且不指定安装到当前目录, 会写入到ruby环境所在文件, 我们系统有可能没有写入权限, 进而报错。</p>
<p>创建文件完成后, 我们在在前目录执行<code>bundle install</code>, 将依赖安装进<code>vendor/bundle</code>中</p>
<p>此时的目录结构为: </p>
<img src="/2020/04/02/optimize-compilation-speed/rubymine_folder.png" class="" title="目录结构">

<h3 id="RubyMine设置"><a href="#RubyMine设置" class="headerlink" title="RubyMine设置"></a>RubyMine设置</h3><p>RubyMine打开<code>imy-bin</code>文件夹, 设置<code>Edit Configurations</code></p>
<img src="/2020/04/02/optimize-compilation-speed/rubymine_gem_config.png" class="" title="配置config">
<img src="/2020/04/02/optimize-compilation-speed/rubymine_gem_bundler.png" class="" title="配置bundler">

<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>我们找到<code>cocoapods-imy-bin</code>插件的中命令<code>pod bin init</code>的函数入口, 打断点。</p>
<p>点击小爬虫, 进行调试: </p>
<img src="/2020/04/02/optimize-compilation-speed/rubymine_breakpoint.png" class="" title="断点">


<p>至此, 我们就可以通过调试, 然后看看<code>cocoapods-imy-bin</code>作者的实现思路以及每一个命令的都做了哪些事情~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xODViMWViNTY4N2I=">rubymine调试cocoapods插件<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly90cmlwbGVjYy5naXRodWIuaW8vMjAxNy8xMS8wOC8yMDE3LTExLTA4LWNodWFuZy1qaWFuLWNvY29hcG9kc2NoYS1qaWFuLw==">编写自己的 CocoaPods 插件<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title>年后开工</title>
    <url>/2018/02/25/start/</url>
    <content><![CDATA[<h2 id="新博客"><a href="#新博客" class="headerlink" title="新博客"></a>新博客</h2><p>以后在这里更新博客了, 在这里记录一些开发经验和一些生活点滴, 以前的文章点击<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vdS9jNGE0NTA1YmVmNGY=">这里<i class="fa fa-external-link-alt"></i></span>, 恩, 就酱…</p>
<span id="more"></span>

<h2 id="新Mac"><a href="#新Mac" class="headerlink" title="新Mac"></a>新Mac</h2><p>年假马上过去了, 年后开工, 买台新电脑犒劳一下自己. <code>2w</code>大洋, 肉疼~~<br>不多说, 赶紧配置起来 ^_^</p>
<h2 id="安装必备软件"><a href="#安装必备软件" class="headerlink" title="安装必备软件"></a>安装必备软件</h2><ol>
<li><p>输入法: 搜狗输入法</p>
</li>
<li><p>Shadowsocks-NG</p>
<blockquote>
<p>这个不多说, 必备</p>
</blockquote>
</li>
<li><p>Chrome浏览器 </p>
<blockquote>
<p>安装<code>JSON Viewer</code>插件, json格式化工具</p>
</blockquote>
</li>
<li><p>Alfred3 </p>
<blockquote>
<p>效率神器 配置所在的路径<code>~/Library/Application Support/Alfred 2/Alfred.alfredpreferences</code>, 从老电脑拷贝到新电脑<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM5MDk4Nzk5">Alfred在不同电脑上同步自定义设置<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
<li><p>iTerm </p>
<blockquote>
<p>配合<code>ZSH</code> 个性化设置</p>
</blockquote>
</li>
<li><p>CleanMyMac 3</p>
<blockquote>
<p>清理MAC</p>
</blockquote>
</li>
<li><p>Teamviewer</p>
<blockquote>
<p>远程协助</p>
</blockquote>
</li>
<li><p>Charles</p>
<blockquote>
<p>抓包工具</p>
</blockquote>
</li>
<li><p>Sketch</p>
<blockquote>
<p>UI设计必备</p>
</blockquote>
</li>
<li><p>Xcode</p>
<blockquote>
<p>iOS开发必备</p>
</blockquote>
</li>
<li><p>微信开发者工具 </p>
</li>
<li><p>Sourcetree</p>
<blockquote>
<p>git可视化工具 </p>
</blockquote>
</li>
<li><p>Phpstorm <span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdm9rZV8vYXJ0aWNsZS9kZXRhaWxzLzc4Nzk0NTY3">激活<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>Reveal</p>
<blockquote>
<p>iPhone app 层级查看</p>
</blockquote>
</li>
<li><p>Mweb </p>
<blockquote>
<p>心仪的<code>Markdown</code>编辑器</p>
</blockquote>
</li>
<li><p>Sequel Pro </p>
<blockquote>
<p>数据库工具</p>
</blockquote>
</li>
<li><p>LICEcap /  Snip</p>
</li>
<li><p>ThemeEngine </p>
<blockquote>
<p>提取iOS assets.car中的图片</p>
</blockquote>
</li>
<li><p>PaintCode </p>
</li>
<li><p>XMind</p>
</li>
<li><p>(Be Focused Pro)番茄闹钟</p>
</li>
<li><p>WWDC</p>
</li>
<li><p>印象笔记</p>
</li>
<li><p>播放器 Blu-ray Player Pro</p>
</li>
<li><p>Dropbox 配置代理服务器</p>
</li>
</ol>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><ol>
<li><p>配置SSH <span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9heXNlZWluZy9wLzQ2NDYyOTIuaHRtbA==">多台电脑公用一个SSH<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>拷贝旧电脑的 .ssh 到新电脑中</p>
</blockquote>
</li>
<li><p>安装<code>Homebrew</code>和<code>wget</code> <span class="exturl" data-url="aHR0cHM6Ly9icmV3LnNoLw==">步骤<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>安装<code>npm</code> <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tLmNuL2dldHRpbmctc3RhcnRlZC9pbnN0YWxsaW5nLW5vZGUv">步骤<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>安装<code>mysql</code> <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2Rvd25sb2Fkcy9teXNxbC8=">dmg安装<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9hYWFhYWFzaHUuZ2l0Ym9va3MuaW8vbWFjLWRldi1zZXR1cC9jb250ZW50L015U3FsL2luZGV4Lmh0bWw=">brew安装<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>安装<code>Composer</code> <span class="exturl" data-url="aHR0cDovL2RvY3MucGhwY29tcG9zZXIuY29tLzAwLWludHJvLmh0bWw=">步骤<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>安装<code>laravel</code> <span class="exturl" data-url="aHR0cHM6Ly9kLmxhcmF2ZWwtY2hpbmEub3JnL2RvY3MvNS41L2luc3RhbGxhdGlvbg==">步骤<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>安装<code>cocopods</code> <span class="exturl" data-url="aHR0cHM6Ly9ndWlkZXMuY29jb2Fwb2RzLm9yZy91c2luZy9nZXR0aW5nLXN0YXJ0ZWQuaHRtbA==">步骤<i class="fa fa-external-link-alt"></i></span>  意外发现根目录下的.cocopods仓库中的目录和以前版本不同了</p>
</li>
<li><p>导出钥匙串中的证书/p12到新电脑中</p>
</li>
<li><p>同步备忘录中的文章信息</p>
</li>
</ol>
<h2 id="配置iterm2-zsh-参考"><a href="#配置iterm2-zsh-参考" class="headerlink" title="配置iterm2/ zsh 参考"></a>配置iterm2/ zsh 参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwOTkxOTcxNA==">https://segmentfault.com/a/1190000009919714<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMDUxODE5NQ==">https://segmentfault.com/a/1190000010518195<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sYW9zaHV0ZXJyeS5naXRib29rcy5pby9tYWNfb3Nfc2V0dXBfZ3VpZGUvY29udGVudC80X1pzaENvbmZpZy5odG1s">https://laoshuterry.gitbooks.io/mac_os_setup_guide/content/4_ZshConfig.html<i class="fa fa-external-link-alt"></i></span><br>ZSH的主题参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JvYmJ5cnVzc2VsbC9vaC1teS16c2gvd2lraS9UaGVtZXM=">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>bash和zsh互相切换</p>
</blockquote>
<ul>
<li>切换bash</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chsh -s &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<ul>
<li>切换zsh</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chsh -s &#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure>


<h2 id="关于环境变量"><a href="#关于环境变量" class="headerlink" title="关于环境变量"></a>关于环境变量</h2><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDQxNjEwMS9hcnRpY2xlL2RldGFpbHMvNTQ2MTg2MjE=">环境变量<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2hpbmVxaXVqdWFuL3AvNDY5MzQwNC5odG1s">MAC设置环境变量path的几种方法<i class="fa fa-external-link-alt"></i></span></p>
<p>1）/etc/paths （全局建议修改这个文件 ）<br>编辑 paths，将环境变量添加到 paths文件中 ，一行一个路径<br>Hint：输入环境变量时，不用一个一个地输入，只要拖动文件夹到 Terminal 里就可以了。</p>
<p>2）/etc/profile （建议不修改这个文件 ）<br>全局（公有）配置，不管是哪个用户，登录时都会读取该文件。</p>
<p>3）/etc/bashrc （一般在这个文件中添加系统级环境变量）<br>全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。</p>
<p>4）<br>1.创建一个文件：<br>sudo touch /etc/paths.d/mysql<br>2.用 vim 打开这个文件（如果是以 open -t 的方式打开，则不允许编辑）：<br>sudo vim /etc/paths.d/mysql<br>3.编辑该文件，键入路径并保存（关闭该 Terminal 窗口并重新打开一个，就能使用 mysql 命令了）<br>/usr/local/mysql/bin<br>这样可以自己生成新的文件，不用把变量全都放到 paths 一个文件里，方便管理。</p>
<blockquote>
<p>.d文件不常见，有可能是某个应用自己特有的文件，.d也可能是default的意思,表示默认（配置）文件，还有可能是Dynamic的意思，表示动态意义的文件。<br>带.d的文件夹比较常见，比如/etc/rc3.d、/etc/dev.d表示文件加下有系统缺省的配置文件。</p>
</blockquote>
<p>profile、bash_profile、bashrc文件的作用与区别参考<br><span class="exturl" data-url="aHR0cHM6Ly9pdGJpbHUuY29tL2xpbnV4L21hbmFnZW1lbnQvTnlJOWNqaXBsLmh0bWw=">https://itbilu.com/linux/management/NyI9cjipl.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qaW5neWFuLmJhaWR1LmNvbS9hcnRpY2xlL2YyNWVmMjU0YThmNGE2NDgyZDFiODI2MS5odG1s">https://jingyan.baidu.com/article/f25ef254a8f4a6482d1b8261.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Live</category>
      </categories>
      <tags>
        <tag>Live</tag>
      </tags>
  </entry>
</search>
